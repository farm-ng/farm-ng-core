"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[629],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>k});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var o=a.createContext({}),p=function(e){var n=a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(o.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(t),m=r,k=u["".concat(o,".").concat(m)]||u[m]||d[m]||l;return t?a.createElement(k,i(i({ref:n},c),{},{components:t})):a.createElement(k,i({ref:n},c))}));function k(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=t.length,i=new Array(l);i[0]=m;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s[u]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<l;p++)i[p]=t[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},9095:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>d,frontMatter:()=>l,metadata:()=>s,toc:()=>p});var a=t(7462),r=(t(7294),t(3905));const l={sidebar_position:1},i="Farm-ng C++ Style Guide",s={unversionedId:"Developer Guide/style-guide",id:"Developer Guide/style-guide",title:"Farm-ng C++ Style Guide",description:"This is the c++ style guide for farm-ng. It does not just apply to",source:"@site/docs/Developer Guide/style-guide.md",sourceDirName:"Developer Guide",slug:"/Developer Guide/style-guide",permalink:"/farm-ng-core/docs/Developer Guide/style-guide",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Contributor Guide",permalink:"/farm-ng-core/docs/category/contributor-guide"}},o={},p=[{value:"Coding standard",id:"coding-standard",level:2},{value:"Code formatting",id:"code-formatting",level:2},{value:"Headers",id:"headers",level:2},{value:"Header include order",id:"header-include-order",level:3},{value:"Naming convention",id:"naming-convention",level:2},{value:"<code>snake_case</code>",id:"snake_case",level:3},{value:"<code>trailing_snake_case_</code>",id:"trailing_snake_case_",level:3},{value:"<code>PascalCase</code>",id:"pascalcase",level:3},{value:"<code>lowerCamelCase</code>",id:"lowercamelcase",level:3},{value:"<code>kLowerCamelCase</code>",id:"klowercamelcase",level:3},{value:"<code>UPPER_CASE</code>",id:"upper_case",level:3},{value:"Acronyms",id:"acronyms",level:3},{value:"Classes and Structs",id:"classes-and-structs",level:2},{value:"Enums",id:"enums",level:2},{value:"Constants",id:"constants",level:2},{value:"Macros",id:"macros",level:2},{value:"Namespaces",id:"namespaces",level:2},{value:"Templates",id:"templates",level:2},{value:"<code>class</code> versus <code>typename</code> in templates",id:"class-versus-typename-in-templates",level:2}],c={toc:p},u="wrapper";function d(e){let{components:n,...t}=e;return(0,r.kt)(u,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"farm-ng-c-style-guide"},"Farm-ng C++ Style Guide"),(0,r.kt)("p",null,"This is the c++ style guide for farm-ng. It does not just apply to\n",(0,r.kt)("em",{parentName:"p"},"farm-ng-core")," but the mentioned libraries above, but other all farm-ng\nlibraries and sister open source projects such as ",(0,r.kt)("em",{parentName:"p"},"Sophus"),"."),(0,r.kt)("h2",{id:"coding-standard"},"Coding standard"),(0,r.kt)("p",null,"We aim for using modern c++. A general good resource for best practice are the\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md"},"https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md"),"."),(0,r.kt)("h2",{id:"code-formatting"},"Code formatting"),(0,r.kt)("p",null,"We use clang-format. See ",(0,r.kt)("inlineCode",{parentName:"p"},".clang-format")," file in the root directory for\ndetails."),(0,r.kt)("h2",{id:"headers"},"Headers"),(0,r.kt)("p",null,"Each header file shall start with a ",(0,r.kt)("inlineCode",{parentName:"p"},"#pragma once")," statement (i.e. right after\nthe copyright / licensing statement)."),(0,r.kt)("h3",{id:"header-include-order"},"Header include order"),(0,r.kt)("p",null,'Header includes should be ordered in groups, proceeding from "local" to "global".\nThis ',(0,r.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/2762568"},"helps ensure")," that local\nheaders are self-sufficient, without implicit dependencies."),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// 1. Corresponding .* file, if we are in a  *.cpp file.\n#include "farm_ng/core/prototools/proto_log_writer.h"\n\n\n// 2. first party\n#include "farm_ng/core/logging/expected.h"\n#include "farm_ng/core/logging/logger.h"\n\n// 3. third-party\n#include <google/protobuf/text_format.h>\n#include <google/protobuf/util/json_util.h>\n\n// 4. c++ standard library and posix\n#include <filesystem>\n#include <fstream>\n')),(0,r.kt)("p",null,"First party headers are included with ",(0,r.kt)("inlineCode",{parentName:"p"},'"path/from/root/foo.h"'),", while\nthird-party packages are included with ",(0,r.kt)("inlineCode",{parentName:"p"},"<package_name/module/file.h>"),". This\ninclude order (1., 2., 3., 4.) convention is enforced by ",(0,r.kt)("inlineCode",{parentName:"p"},"clang-format")," if\n",(0,r.kt)("inlineCode",{parentName:"p"},'"brackets"')," (1., 2.) versus ",(0,r.kt)("inlineCode",{parentName:"p"},"<brackets>")," (3., 4.) are used accordingly."),(0,r.kt)("p",null,"Notes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'In downstream dependencies, open source libraries such as "farm-ng-core"\nand "sophus" are considered third-party and included with ',(0,r.kt)("inlineCode",{parentName:"li"},"<brackets>"),"."),(0,r.kt)("li",{parentName:"ul"},"When using C library header one shall prefer C++ library version, over the\nC-library version: ",(0,r.kt)("inlineCode",{parentName:"li"},"#include <cmath>")," instead of ",(0,r.kt)("inlineCode",{parentName:"li"},"#include <math.h>"),".")),(0,r.kt)("h2",{id:"naming-convention"},"Naming convention"),(0,r.kt)("p",null,"Most naming conventions are enforced by clang-tidy. See ",(0,r.kt)("inlineCode",{parentName:"p"},".clang-tidy")," in the\nroot for details."),(0,r.kt)("h3",{id:"snake_case"},(0,r.kt)("inlineCode",{parentName:"h3"},"snake_case")),(0,r.kt)("p",null,"Variable names are typically written in ",(0,r.kt)("inlineCode",{parentName:"p"},"snake_case"),", e.g.:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"  int count = 0;\n  std::vector<double> floating_point_numbers = {0.1, 0.3};\n  size_t num_numbers = floating_point_numbers.size();\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"snake_case")," is also used for namespaces, see below."),(0,r.kt)("h3",{id:"trailing_snake_case_"},(0,r.kt)("inlineCode",{parentName:"h3"},"trailing_snake_case_")),(0,r.kt)("p",null,"Private member variables of classes are written in ",(0,r.kt)("inlineCode",{parentName:"p"},"trailing_snake_case_"),",\ne.g.:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"    class Foo {\n     public:\n      /* details */\n\n     private:\n      std::vector<int> integers_;\n      Bar internal_state_;\n    }\n")),(0,r.kt)("h3",{id:"pascalcase"},(0,r.kt)("inlineCode",{parentName:"h3"},"PascalCase")),(0,r.kt)("p",null,"Type names, including class names, struct names and typedefs, are written in\n",(0,r.kt)("inlineCode",{parentName:"p"},"PascalCase"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"    struct Foo {};\n\n    class Bar {\n      /* details */\n    };\n\n    using FooBarVariant = std::variant<Foo, Bar>;\n")),(0,r.kt)("h3",{id:"lowercamelcase"},(0,r.kt)("inlineCode",{parentName:"h3"},"lowerCamelCase")),(0,r.kt)("p",null,"Function, including free functions and class methods are written in\n",(0,r.kt)("inlineCode",{parentName:"p"},"lowerCamelCase"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"    void solveSubProblem(const Input& input);\n\n    class Bar {\n     public:\n      DebugOutput debugOutput();\n    };\n\n    Foo fooFromBar(const Bar& bar);\n")),(0,r.kt)("p",null,"Notes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"By default, don't use ",(0,r.kt)("inlineCode",{parentName:"li"},"getPrefixes")," for getter function, e.g. use\n",(0,r.kt)("inlineCode",{parentName:"li"},"debugOutput")," and not ",(0,r.kt)("inlineCode",{parentName:"li"},"getDebugOutput"),"."),(0,r.kt)("li",{parentName:"ul"},"Lambda expressions names are considered variables and hence we use\n",(0,r.kt)("inlineCode",{parentName:"li"},"snake_case"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"    auto solve_sub_problem = [&input]() { return solveSubProblem(input); }\n")),(0,r.kt)("h3",{id:"klowercamelcase"},(0,r.kt)("inlineCode",{parentName:"h3"},"kLowerCamelCase")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"kLowerCamelCase")," is used for global and static class constants, constexpr\nconstants and value class templates see below."),(0,r.kt)("h3",{id:"upper_case"},(0,r.kt)("inlineCode",{parentName:"h3"},"UPPER_CASE")),(0,r.kt)("p",null,"Macros only. See below."),(0,r.kt)("h3",{id:"acronyms"},"Acronyms"),(0,r.kt)("p",null,"Acronyms and contractions count as one word. That is we have ",(0,r.kt)("inlineCode",{parentName:"p"},"SlamResult"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"HttpRequest")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Se3Group")," (and not ",(0,r.kt)("inlineCode",{parentName:"p"},"SLAMResult"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"HTTPRequest"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"SE3Group"),") in UpperCamelCase and ",(0,r.kt)("inlineCode",{parentName:"p"},"slam_result")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"http_request")," in\nsnake_case."),(0,r.kt)("h2",{id:"classes-and-structs"},"Classes and Structs"),(0,r.kt)("p",null,"While C++ allows for a great flexibility, we impose some guidelines when to use\nstructs vs. classes."),(0,r.kt)("p",null,"For POD-like collections we use the struct keyword::"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"    struct Collection {\n      std::vector<int> integers;\n      std::string description;\n    };\n")),(0,r.kt)("p",null,"Such structs must not have private members. They may or may not have have member\nfunctions, and constructors. For the public member variables we use\n",(0,r.kt)("inlineCode",{parentName:"p"},"snake_case")," naming."),(0,r.kt)("p",null,"For entities with non-trivial type invariant, we use the class keyword::"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"    template <class T>\n    class UnitVector3 {\n     public:\n      // Precondition: v must be of unit length.\n      static UnitVector3 fromUnitVector(const Eigen::Matrix<T, 3, 1>& v) {\n        using std::abs;\n        FARM_ASSERT_LE((v.squaredNorm() - T(1.0)),\n                         Sophus::kEpsilon<TT>);\n        UnitVector3 unit_vector;\n        unit_vector.vector_ = v;\n        return unit_vector;\n      }\n\n\n      static UnitVector3 fromVectorAndNormalize(\n          const Eigen::Matrix<T, 3, 1>& v) {\n        return fromUnitVector(v.normalized());\n      }\n\n      const Eigen::Matrix<T, 3, 1>& vector() const { return vector_; }\n\n     private:\n      UnitVector3() {}\n\n      // Class invariant: v_ is of unit length.\n      Eigen::Matrix<T, 3, 1> vector_;\n    };\n")),(0,r.kt)("p",null,"Classes shall start with all public member (constructors, destructors, member\nfunctions etc.) then followed by private members (member functions then member\nvariables). Classes shall not have any public member variables. Use public\naccessors/mutators instead:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"    class MyClass {\n    public:\n      /* details */\n\n      // accessor\n      [[nodiscard]] const std::vector<double>& rawValues() const {\n        return raw_values_;\n      }\n\n      // mutator\n      std::vector<double>& mutRawValues() {\n        return raw_values_;\n      }\n\n\n    private:\n      std::vector<double> raw_values_;\n    };\n")),(0,r.kt)("p",null,"Notes about class/struct methods:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Do not prefix an accessor with ",(0,r.kt)("inlineCode",{parentName:"li"},"get"),"."),(0,r.kt)("li",{parentName:"ul"},"It is good practice to annotate a constant ref accessor with\n",(0,r.kt)("inlineCode",{parentName:"li"},"[[nodiscard]]"),"."),(0,r.kt)("li",{parentName:"ul"},"Consider prefixing mutators and other non-const methods with\n",(0,r.kt)("inlineCode",{parentName:"li"},"mut"),". This is inspired by the ",(0,r.kt)("inlineCode",{parentName:"li"},"mut")," postfix convention in rust (e.g.\n",(0,r.kt)("a",{parentName:"li",href:"https://doc.rust-lang.org/std/vec/struct.Vec.html#method.last_mut"},"https://doc.rust-lang.org/std/vec/struct.Vec.html#method.last_mut"),") and it is\nsimilar to the rational of the introduction of ",(0,r.kt)("inlineCode",{parentName:"li"},"cbegin/cend")," to the c++\nstandard (as motivated here\n",(0,r.kt)("a",{parentName:"li",href:"https://stackoverflow.com/questions/12001410/what-is-the-reason-behind-cbegin-cend"},"https://stackoverflow.com/questions/12001410/what-is-the-reason-behind-cbegin-cend"),")."),(0,r.kt)("li",{parentName:"ul"},"For implementation details, hence code not part of a public API, such as\ntrait classes, ceres::Cost functors, Impl classes (e.g. when using the Pimpl\nidiom: ",(0,r.kt)("a",{parentName:"li",href:"http://bitboom.github.io/pimpl-idiom"},"http://bitboom.github.io/pimpl-idiom"),"), it is fine to a have a\nclass/struct with all public member variables.")),(0,r.kt)("h2",{id:"enums"},"Enums"),(0,r.kt)("p",null,"Prefer use enum classes defined through the FARM_ENUM macro."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"    FARM_ENUM(VizMaterialType, (ambient, diffuse, phong));\n")),(0,r.kt)("p",null,"Note: we use ",(0,r.kt)("inlineCode",{parentName:"p"},"snake_case")," for enum value names, such that the\ncorresponding strings are more user-friendly, e.g. when passing\nin values through CLI11:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'    std::string example_input = "ambient";\n    VizMatrialType material;\n    FARM_ASSERT(trySetFromString(material, example_input));\n')),(0,r.kt)("h2",{id:"constants"},"Constants"),(0,r.kt)("p",null,"For global and static class constants, we use the ",(0,r.kt)("inlineCode",{parentName:"p"},"kLowerCamelCase")," naming\nconventions. Examples::"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"    constexpr double kPi = 3.14159265359;\n\n    class Variable5Dof {\n     public:\n      static constexpr int kNumDegreesOfFreedom = 5;\n\n      /* details */\n    };\n")),(0,r.kt)("h2",{id:"macros"},"Macros"),(0,r.kt)("p",null,"Avoid using macros, especially if the same behaviors can be achieved through\nconstants or C++ templates."),(0,r.kt)("p",null,"For all marcos we use the ",(0,r.kt)("inlineCode",{parentName:"p"},"FARM_UPPER_CASE")," naming style. In particular,\nall farm-ng macro names shall be prefixed by ",(0,r.kt)("inlineCode",{parentName:"p"},"FARM_")," (and for sister open\nsource libraries accordingly, ",(0,r.kt)("inlineCode",{parentName:"p"},"SOPHUS_")," for Sophus etc.).\nExample:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"    #define FARM_FORMAT(cstr, ...)                             \\\n        /* FMT_STRING is defined in the <fmt/format.h> header */  \\\n        ::fmt::format(FMT_STRING(cstr), __VA_ARGS__)\n")),(0,r.kt)("p",null,"Note:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Marcos provided by farm-ng-core in generally provide functionallity not\nsupported otherwise, such as line number log output for ASSERT macros,\nto/from string conversions for enums etc.")),(0,r.kt)("h2",{id:"namespaces"},"Namespaces"),(0,r.kt)("p",null,"For namespace hierarchy, we believe more is less. That is most of the code shall\nbe defined within the top-level namespace, e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"farm-ng")," for the\nfarm-ng-core, ",(0,r.kt)("inlineCode",{parentName:"p"},"sophus")," for Sophus library, etc."),(0,r.kt)("p",null,"For implementation details (e.g. in header only libraries), we use the\n",(0,r.kt)("inlineCode",{parentName:"p"},"farm-ng::details")," namespace."),(0,r.kt)("p",null,"All namespace names are in ",(0,r.kt)("inlineCode",{parentName:"p"},"snake_case"),"."),(0,r.kt)("h2",{id:"templates"},"Templates"),(0,r.kt)("p",null,"Use reasonable. Compile time matters too. Non-type template parameters use\n",(0,r.kt)("inlineCode",{parentName:"p"},"kCamelCae")," while type parameters use ",(0,r.kt)("inlineCode",{parentName:"p"},"TCamelCase"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template <class TScalar, int kRows, int kCols>\nclass MaxMetric<Eigen::Matrix<TScalar, kRows, kCols>> {\n public:\n  using Scalar = TScalar;\n\n  ...\n}\n")),(0,r.kt)("h2",{id:"class-versus-typename-in-templates"},(0,r.kt)("inlineCode",{parentName:"h2"},"class")," versus ",(0,r.kt)("inlineCode",{parentName:"h2"},"typename")," in templates"),(0,r.kt)("p",null,"tldr: We use ",(0,r.kt)("inlineCode",{parentName:"p"},"class"),"."),(0,r.kt)("p",null,"Both keywords are interchangeable in this context:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<class T>\nclass Foo {\n}\n")),(0,r.kt)("p",null,"versus"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename T>\nclass Foo {\n};\n")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://stackoverflow.com/a/2024173"},"*"),"."),(0,r.kt)("p",null,"We use the ",(0,r.kt)("inlineCode",{parentName:"p"},"class")," key name in (class, function, variable) templates\nalways"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"to be consistent,"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"class")," is less letters to type than ",(0,r.kt)("inlineCode",{parentName:"li"},"typename"),","),(0,r.kt)("li",{parentName:"ul"},"possibly easier to parse in complex expressions\n(",(0,r.kt)("inlineCode",{parentName:"li"},"class")," looks less similar to ",(0,r.kt)("inlineCode",{parentName:"li"},"template")," keyword).")))}d.isMDXComponent=!0}}]);