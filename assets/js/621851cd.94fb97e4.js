"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[592],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=o.createContext({}),p=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=p(e.components);return o.createElement(s.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},f=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(n),f=r,h=d["".concat(s,".").concat(f)]||d[f]||m[f]||i;return n?o.createElement(h,a(a({ref:t},c),{},{components:n})):o.createElement(h,a({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,a=new Array(i);a[0]=f;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:r,a[1]=l;for(var p=2;p<i;p++)a[p]=n[p];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}f.displayName="MDXCreateElement"},2311:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var o=n(7462),r=(n(7294),n(3905));const i={sidebar_position:1},a="Transformations, points, frames and velocities",l={unversionedId:"Developer Guide/poses_and_frames",id:"Developer Guide/poses_and_frames",title:"Transformations, points, frames and velocities",description:"Rigid body transform and points convention",source:"@site/docs/Developer Guide/poses_and_frames.md",sourceDirName:"Developer Guide",slug:"/Developer Guide/poses_and_frames",permalink:"/farm-ng-core/docs/Developer Guide/poses_and_frames",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Contributor Guide",permalink:"/farm-ng-core/docs/category/contributor-guide"},next:{title:"C++ Style Guide",permalink:"/farm-ng-core/docs/Developer Guide/style-guide"}},s={},p=[{value:"Rigid body transform and points convention",id:"rigid-body-transform-and-points-convention",level:2},{value:"Some details",id:"some-details",level:3},{value:"Velocity, acceleration convention",id:"velocity-acceleration-convention",level:2},{value:"More about the three frames involved",id:"more-about-the-three-frames-involved",level:3},{value:"Velocities in opposite directions",id:"velocities-in-opposite-directions",level:4},{value:"Zero velocity",id:"zero-velocity",level:4},{value:"The adjoint and change of origin",id:"the-adjoint-and-change-of-origin",level:4}],c={toc:p},d="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"transformations-points-frames-and-velocities"},"Transformations, points, frames and velocities"),(0,r.kt)("h2",{id:"rigid-body-transform-and-points-convention"},"Rigid body transform and points convention"),(0,r.kt)("p",null,"Given a point in frame ",(0,r.kt)("inlineCode",{parentName:"p"},"foo"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"bar_from_foo")," is the rigid body\ntransform which maps the point to frame ",(0,r.kt)("inlineCode",{parentName:"p"},"bar"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"    point_in_bar = bar_from_foo * point_in_foo\n")),(0,r.kt)("p",null,"Note that the frame names line up: ",(0,r.kt)("inlineCode",{parentName:"p"},"bar")," - ",(0,r.kt)("inlineCode",{parentName:"p"},"bar"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"foo")," - ",(0,r.kt)("inlineCode",{parentName:"p"},"foo"),"."),(0,r.kt)("h3",{id:"some-details"},"Some details"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If necessary to resolved ambiguities, e.g. between rotations and rigid\nbody transforms, we use a corresponding notation, e.g.\n",(0,r.kt)("inlineCode",{parentName:"p"},"bar_form_foo_rotation"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"bar_form_foo_se3s")," etc.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If we have a list (or vector, or map) of transforms we write:, e.g.:"),(0,r.kt)("p",{parentName:"li"},"   bar_from_foo_rotations")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Transforms with compound frame names, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"robot_base")," or\n",(0,r.kt)("inlineCode",{parentName:"p"},"left_camera"),", are written as follows::"),(0,r.kt)("p",{parentName:"li"},"   robot_base_from_left_camera")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"For functions and methods we use ",(0,r.kt)("inlineCode",{parentName:"p"},"camelCase"),". Examples::"),(0,r.kt)("p",{parentName:"li"},"   this->calcRobotBaseFromLeftCamera();"),(0,r.kt)("p",{parentName:"li"},"   other->setBarFromFoo(bar_from_foo);")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"We use the ",(0,r.kt)("inlineCode",{parentName:"p"},"entity_in_frame")," conventions for points and other entities\nwhich have one frame attached to it. Examples:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"point_in_camera")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"circle_in_image")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"camera_position_in_world")," (or short ",(0,r.kt)("inlineCode",{parentName:"li"},"camera_in_world"),")"),(0,r.kt)("li",{parentName:"ul"},"..."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"When storing transforms / using them in interfaces, prefer the\n",(0,r.kt)("inlineCode",{parentName:"p"},"parent_from_child")," convention."),(0,r.kt)("p",{parentName:"li"},"E.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"world_from_sensor_rig"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"sensor_rig_from_camera"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"robot_from_imu")," (and not ",(0,r.kt)("inlineCode",{parentName:"p"},"sensor_rig_from_world")," etc.)."),(0,r.kt)("p",{parentName:"li"},"It is easier to reason about the pose of camera in the world frame, then\nthe pose of the world origin in the camera frame."))),(0,r.kt)("h2",{id:"velocity-acceleration-convention"},"Velocity, acceleration convention"),(0,r.kt)("p",null,"This section includes convention for entities which require three frames such\nas velocities, and accelerations. We will focus the discussion on velocities,\nbut the same conventions apply to accelerations and similar entities similarly."),(0,r.kt)("p",null,"For velocities, the three frame of interest are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("strong",{parentName:"li"},"anchor frame")," we compare the motion to"),(0,r.kt)("li",{parentName:"ul"},"the frame of the ",(0,r.kt)("strong",{parentName:"li"},"entity")," in motion"),(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("strong",{parentName:"li"},"frame of origin")," in which the velocity is expressed")),(0,r.kt)("p",null,"Let ",(0,r.kt)("inlineCode",{parentName:"p"},"foo")," by the anchor frame, ",(0,r.kt)("inlineCode",{parentName:"p"},"entity")," the frame on the body in motion\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"origin")," the origin frame.\nThen we write:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"foo_anchored_entity_velocity_in_origin\n")),(0,r.kt)("p",null,"Let first give a few examples to illustrate velocities of rigid bodies in\ngeneral, why we need three frames to annotate velocities, and what the\ndifference between is between the anchor frame and the origin is:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"world_anchored_robot_velocity_in_robot"),": Ego-centric velocity of the robot\nwith respect to the world frame, expressed in the robot frame. For 2d\nisometries, the velocity or tangent vector is a 3-vector (vx, vy, w),\nwhich consists of linear velocity (vx, vy) - i.e. forward and sideway and\nangular rate (w). For 3d rigid body transforms, the velocity vector is a\n6-vector (vx, vy, vz, wx, wy, wz), which consists of linear velocity (vx,\nvy, vz) and angular rate (wx, wy, wz).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"world_anchored_robot_velocity_in_world"),": Velocity of the\nrobot with respect to the world frame, expressed in the world frame. Here,\nthe velocities (such as the linear vx, vy) are not ego-centric\n(forward, sideways) but world-centric (e.g. North-South, East-West).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"car1_anchored_car2_velocity_in_track"),": Relative velocity of car2 with\nrespect to car1, expressed in the race track frame."))),(0,r.kt)("p",null,"It is cumbersome, to always annotate velocities with three frames. If it is\nclear from context what"),(0,r.kt)("p",null,"  (a) the anchor frame (e.g. the world frame) and the\n(b) entity in motion is (e.g. the robot),"),(0,r.kt)("p",null,"we use the following conventions which only annotate the origin frame:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"velocity_in_bar\n")),(0,r.kt)("p",null,"which is short for ",(0,r.kt)("inlineCode",{parentName:"p"},"world_anchored_robot_velocity_in_bar"),". In particular,\nwe write:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"velocity_in_world\n")),(0,r.kt)("p",null,"for the world-centric velocity ",(0,r.kt)("inlineCode",{parentName:"p"},"world_anchored_robot_velocity_in_world "),"\n(robot is moving WEST with a speed of 5 mps), and"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"velocity_in_robot\n")),(0,r.kt)("p",null,"for the egocentric velocity ",(0,r.kt)("inlineCode",{parentName:"p"},"world_anchored_robot_velocity_in_robot")," (robot is\nmoving forward with a speed of 5 mps)."),(0,r.kt)("h3",{id:"more-about-the-three-frames-involved"},"More about the three frames involved"),(0,r.kt)("h4",{id:"velocities-in-opposite-directions"},"Velocities in opposite directions"),(0,r.kt)("p",null,"It is important to note that swapping the ",(0,r.kt)("strong",{parentName:"p"},"anchor")," frame and the ",(0,r.kt)("strong",{parentName:"p"},"entity"),"\nframe does result in the velocity with opposite direction. That is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"foo_anchored_bar_velocity_in_origin = -bar_anchored_foo_velocity_in_origin\n")),(0,r.kt)("p",null,"Let look at two race cars example. If car1 is moving with a speed\nof 5 mps with respect to car2, then car2 is moving with a speed of -5 mps with\nrespect to car1. (Car1 is 5mph faster than car2, or hence car2 is 5mph slower\nthan car1.)"),(0,r.kt)("p",null,"We call a velocity ego-centric if the origin frame is the entity frame."),(0,r.kt)("h4",{id:"zero-velocity"},"Zero velocity"),(0,r.kt)("p",null,"If the entity frame equals the anchor frame, then the velocity is zero by\ndefinition. This trivial case is not interesting. (If you were to see non-zero\nvelocities foo_anchored_foo_velocity_in_bar in code, the notation is not used\ncorrectly.)"),(0,r.kt)("h4",{id:"the-adjoint-and-change-of-origin"},"The adjoint and change of origin"),(0,r.kt)("p",null,"Changing the origin frame is done using the adjoint map. Let ",(0,r.kt)("inlineCode",{parentName:"p"},"robot")," be an entity\nin motion with respect to the ",(0,r.kt)("inlineCode",{parentName:"p"},"world")," frame, and have the following velocity:\n",(0,r.kt)("inlineCode",{parentName:"p"},"world_anchored_robot_velocity_in_robot"),".  If we want to express the velocity\nof the robot in a different frame, e.g. a ",(0,r.kt)("inlineCode",{parentName:"p"},"sensor")," frame, we use the adjoint map:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"world_anchored_robot_velocity_in_sensor\n= sensor_from_robot.adjoint() * world_anchored_robot_velocity_in_robot\n")),(0,r.kt)("p",null,"where ",(0,r.kt)("inlineCode",{parentName:"p"},"sensor_from_robot.adjoint()")," is the adjoint map of the rigid body transform\n",(0,r.kt)("inlineCode",{parentName:"p"},"sensor_from_robot"),". Note that applying the adjoint map only changes the\norigin frame, but the other two frames (anchor and entity) stay the same."),(0,r.kt)("p",null,"The adjoint map can also be used to change from world-centric to egocentric\nvelocities. Let ",(0,r.kt)("inlineCode",{parentName:"p"},"sensor")," be a body in motion with respect to the ",(0,r.kt)("inlineCode",{parentName:"p"},"world"),"\nframe, and it has the following world-centric velocity:\n",(0,r.kt)("inlineCode",{parentName:"p"},"world_anchored_sensor_velocity_in_world"),".  If we want to express\nthe of velocity in the sensor frame, we use the adjoint map:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"world_anchored_sensor_velocity_in_sensor\n= sensor_from_world.adjoint() * world_anchored_sensor_velocity_in_world\n")),(0,r.kt)("p",null,"Note, that ",(0,r.kt)("inlineCode",{parentName:"p"},"world_anchored_sensor_velocity_in_sensor")," is still the velocity of\nthe sensor (with respect to the world frame), but expressed in the sensor frame.\nA different but related quantity is the velocity of the world (with respect to\nthe sensor frame) expressed in the sensor frame:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sensor_anchored_world_velocity_in_sensor\n= -(sensor_from_world.adjoint() * world_anchored_sensor_velocity_in_world)\n= -world_anchored_sensor_velocity_in_sensor\n\n")),(0,r.kt)("p",null,"While the concept of world velocity expressed in the sensor frame may sound\nstrange, it is a useful quantity. For instance to describe a sensor model (e.g.\nfor a lidar on a self driving car), it would make sense to talk about the\nvelocity of measured world points expressed in the sensor frame."))}m.isMDXComponent=!0}}]);